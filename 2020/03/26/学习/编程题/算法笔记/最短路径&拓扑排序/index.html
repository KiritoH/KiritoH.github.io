<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"kiritoh.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="最短路径和拓扑排序最短路径解决的问题：    Dijkstra算法 直接把算法笔记上的例子看一下吧以下是截图。      好的，这里是伪代码： 12345678910111213&#x2F;&#x2F;G为图，一般设为全局变量，数组d为源点到达各点的最短路径长度，s为起点Dijkstra(G, d[], s) &amp;#123;    初始化;    for(循环n次) &amp;#123;        u &#x3D; 是d[u]最小的">
<meta property="og:type" content="article">
<meta property="og:title" content="最短路径和拓扑排序">
<meta property="og:url" content="http://kiritoh.github.io/2020/03/26/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/index.html">
<meta property="og:site_name" content="KiritoH&#39;s Blog">
<meta property="og:description" content="最短路径和拓扑排序最短路径解决的问题：    Dijkstra算法 直接把算法笔记上的例子看一下吧以下是截图。      好的，这里是伪代码： 12345678910111213&#x2F;&#x2F;G为图，一般设为全局变量，数组d为源点到达各点的最短路径长度，s为起点Dijkstra(G, d[], s) &amp;#123;    初始化;    for(循环n次) &amp;#123;        u &#x3D; 是d[u]最小的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200331204944554.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165214078.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165304552.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165412638.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165433888.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403170001655.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403211036400.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403211611022.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405215812768.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405222518924.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405223739577.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414102153377.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414103009429.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414103213661.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414104326841.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414105020615.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406210445011.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406211123526.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406211138761.png">
<meta property="og:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406214036081.png">
<meta property="article:published_time" content="2020-03-26T09:42:56.860Z">
<meta property="article:modified_time" content="2020-06-10T00:47:17.237Z">
<meta property="article:author" content="KiritoH">
<meta property="article:tag" content="最短路径&amp;拓扑排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200331204944554.png">

<link rel="canonical" href="http://kiritoh.github.io/2020/03/26/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>最短路径和拓扑排序 | KiritoH's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">KiritoH's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://kiritoh.github.io/2020/03/26/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84&%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/01.jpg">
      <meta itemprop="name" content="KiritoH">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="KiritoH's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          最短路径和拓扑排序
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-26 17:42:56" itemprop="dateCreated datePublished" datetime="2020-03-26T17:42:56+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-06-10 08:47:17" itemprop="dateModified" datetime="2020-06-10T08:47:17+08:00">2020-06-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">编程题</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">算法笔记</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="最短路径和拓扑排序"><a href="#最短路径和拓扑排序" class="headerlink" title="最短路径和拓扑排序"></a>最短路径和拓扑排序</h1><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><p>解决的问题：</p>
<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200331204944554.png" alt="image-20200331204944554"></p>
</blockquote>
<h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a>Dijkstra算法</h3><blockquote>
<p>直接把算法笔记上的例子看一下吧以下是截图。</p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165214078.png" alt="image-20200403165214078"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165304552.png" alt="image-20200403165304552"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165412638.png" alt="image-20200403165412638"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403165433888.png" alt="image-20200403165433888"></p>
</blockquote>
<p>好的，这里是伪代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//G为图，一般设为全局变量，数组d为源点到达各点的最短路径长度，s为起点</span></span><br><span class="line">Dijkstra(G, d[], s) &#123;</span><br><span class="line">    初始化;</span><br><span class="line">    <span class="keyword">for</span>(循环n次) &#123;</span><br><span class="line">        u = 是d[u]最小的还未被访问的顶点的标号;</span><br><span class="line">        记u已被访问;</span><br><span class="line">        <span class="keyword">for</span>(从u出发能到达的所有顶点v)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v未被访问 &amp;&amp; 以u为中介点使s到顶点v的最短距离d[v]更优) &#123;</span><br><span class="line">                优化d[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403170001655.png" alt="image-20200403170001655"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>;  <span class="comment">//最大顶点数</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;  <span class="comment">//设INF为一个很大的数</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>邻接矩阵版—-有向图（无向图相当于有向图每条边都变为两条方向的边，边权值相同）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[MAXV][MAXV]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV]; <span class="comment">//存放由s点到其他各点的距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//访问数组,表示此节点已被访问（最小距离已经确定）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="comment">//s为起点</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);  <span class="comment">//先都设置不可达</span></span><br><span class="line">    d[s] = <span class="number">0</span>;  <span class="comment">//自己为0</span></span><br><span class="line">    <span class="comment">//vis[s] = true;不可设置为true，必须第一次循环为s，这样才是从s往其他结点</span></span><br><span class="line">    <span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//i为节点大小</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;<span class="comment">//用来标记</span></span><br><span class="line">        <span class="comment">//得到路径最小的且没有访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">				<span class="comment">//之所以要用MIN和u组合，是因为如果直接用u</span></span><br><span class="line">                <span class="comment">//并不存在d[-1],也不能直接等于其中一个，因为不知道有没有访问过</span></span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u = <span class="number">-1</span>) <span class="keyword">return</span>;  <span class="comment">//说明找不到</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;      <span class="comment">//找得到，标记为true</span></span><br><span class="line">        <span class="comment">//更新由该节点出发的更优最短路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//未访问&amp;&amp;由u可到达&amp;&amp;比距离表里更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF &amp;&amp; d[u] + G[u][j] &lt; d[j]) &#123;</span><br><span class="line">                d[j] = d[u] + G[u][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接表版</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v; <span class="comment">//点的下标</span></span><br><span class="line">    <span class="keyword">int</span> w; <span class="comment">//边权</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;Node&gt; Adj[MAXV];  <span class="comment">//之所以采用这种形式，而不是二重vector，是因为第一层只需要一个数字标识下标</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];  <span class="comment">//距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;; <span class="comment">//访问数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXN, INF);</span><br><span class="line">    <span class="comment">//vis[s] = true;不可设置为true，必须第一次循环为s，这样才是从s往其他结点</span></span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//最外层循环每一次必有一个结点访问</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//找最小的未访问结点</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">  				u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">		<span class="comment">//邻接表写法和邻接矩阵写法的不同之处：</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; Adj[u].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[Adj[u][j].v] == <span class="literal">false</span> </span><br><span class="line">               <span class="comment">//&amp;&amp; Adj[u][j].w != INF //这个不用判断，因为邻接表特性！</span></span><br><span class="line">               &amp;&amp; Adj[u][j].w + d[u] &lt; d[Adj[u][j].v])&#123;</span><br><span class="line">                d[Adj[u][j].v] = Adj[u][j].w + d[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<pre><code>但是以上只是求出了最短距离，而非最短路径，如果要得到最短路径，还需要一些措施：

&gt; ![image-20200403204421924](https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403204421924.png)

所以很容易实现：

邻接矩阵为例：

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[MAXV][MAXV]; <span class="comment">//邻接矩阵</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV]; <span class="comment">//存放由s点到其他各点的距离</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//访问数组,表示此节点已被访问（最小距离已经确定）</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXV];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123; <span class="comment">//s为起点</span></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);  <span class="comment">//先都设置不可达</span></span><br><span class="line">    d[s] = <span class="number">0</span>;  <span class="comment">//自己为0</span></span><br><span class="line">    <span class="comment">//vis[s] = true;不可设置为true，必须第一次循环为s，这样才是从s往其他结点</span></span><br><span class="line">    <span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">//i为节点大小</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;<span class="comment">//用来标记</span></span><br><span class="line">        <span class="comment">//得到路径最小的且没有访问过的节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">				<span class="comment">//之所以要用MIN和u组合，是因为如果直接用u</span></span><br><span class="line">                <span class="comment">//并不存在d[-1],也不能直接等于其中一个，因为不知道有没有访问过</span></span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u = <span class="number">-1</span>) <span class="keyword">return</span>;  <span class="comment">//说明找不到</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;      <span class="comment">//找得到，标记为true</span></span><br><span class="line">        <span class="comment">//更新由该节点出发的更优最短路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//未访问&amp;&amp;由u可到达&amp;&amp;比距离表里更优</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF &amp;&amp; d[u] + G[u][j] &lt; d[j]) &#123;</span><br><span class="line">                d[j] = d[u] + G[u][j];</span><br><span class="line">                pre[j] = u;(新添加。。。。。。。。。。。。就这一行)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

那么想拿到一组路径呢？

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不断向前即可</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s == e)&#123;<span class="comment">//到起点，输出并返回，这是因为pre[s]本身是不存在的，所以进行特判</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(pre[e]);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;e&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p>前面是Dijkstra的基本形式，但是考试可能会更难：(第二标尺)</p>
<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403211036400.png" alt="image-20200403211036400">)<img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200403211611022.png" alt="image-20200403211611022"></p>
</blockquote>
<ul>
<li>新增边权</li>
</ul>
<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405215812768.png" alt="image-20200405215812768"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实际上需要改的只有最后一个for循环处，但是我想把所有的再默写一遍</span></span><br><span class="line"><span class="keyword">int</span> G[MAXV][MAXV]; <span class="comment">//存每条边的距离</span></span><br><span class="line"><span class="keyword">int</span> d[MAXV];  <span class="comment">//存最短距离，核心算法便是在维护这个数组，目前s到u的最短距离为d[u]</span></span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;  <span class="comment">//是否访问过</span></span><br><span class="line"><span class="keyword">int</span> pre[MAXV];  <span class="comment">//前一个</span></span><br><span class="line"><span class="keyword">int</span> cost[MAXV][MAXV];  <span class="comment">//存每条边的花费</span></span><br><span class="line"><span class="keyword">int</span> c[MAXV]; <span class="comment">//s到u的最小花费为c[u]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + MAXV, INF);</span><br><span class="line">    <span class="built_in">fill</span>(c, c + MAXV, INF); <span class="comment">/*注意看区别点！！！！！*/</span></span><br><span class="line">    d[s] = <span class="number">0</span>;	</span><br><span class="line">    c[s] = <span class="number">0</span>;	<span class="comment">/*注意看区别点！！！！！*/</span></span><br><span class="line">    <span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//先找到未访问过的且最短距离的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//没有连接点了</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//再访问该点所连接的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;   <span class="comment">/*注意看区别点！！！！！*/</span></span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span>(G[u][j] + d[u] &lt; d[j]) &#123;</span><br><span class="line">                    d[j] = G[u][j] + d[u];</span><br><span class="line">                    c[j] = cost[u][j] + c[u];</span><br><span class="line">                    pre[j] = u;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(G[u][j] + d[u] == d[j] &amp;&amp; cost[u][j] + c[u] &lt; c[j]) &#123; </span><br><span class="line">                    <span class="comment">//只用更新c[j],因为d[j]同，但是如果要存结点顺序，可以不用这么写，两个if可以放一起！</span></span><br><span class="line">                    c[j] = cost[u][j] + c[u];</span><br><span class="line">                    pre[j] = u;   <span class="comment">//以下两个例子我不会写这部分，这里写了是为了复习一下</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>新增点权</p>
<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405222518924.png" alt="image-20200405222518924"></p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下为不完整代码，只写了改动处，对照前面的来理解</span></span><br><span class="line"><span class="keyword">int</span> weight[MAXV];</span><br><span class="line"><span class="keyword">int</span> w[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">fill</span>(w, w + MAXV, <span class="number">0</span>);</span><br><span class="line">w[s] = weight[s];</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心--对连接结点进行更新</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][j] + d[u] &lt; d[j]) &#123;</span><br><span class="line">            d[j] = d[u] + G[u][j];</span><br><span class="line">            w[j] = w[u] + weight[j];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(G[u][j] + d[u] == d[j] &amp;&amp; w[u] + weight[j] &gt; w[j])&#123;</span><br><span class="line">            w[j] = w[u] + weight[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>求最短路径条数</p>
<p>  <img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200405223739577.png" alt="image-20200405223739577"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[MAXV];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">fill</span>(num, num + MAXV, <span class="number">0</span>);</span><br><span class="line">num[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//核心--访问邻接点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123;</span><br><span class="line">        <span class="keyword">if</span>(G[u][j] + d[u] &lt; d[j]) &#123;</span><br><span class="line">            d[j] = G[u][j] + d[u];</span><br><span class="line">            num[j] = num[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(G[u][j] + d[u] == d[j]) &#123;</span><br><span class="line">            num[j] += num[u];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//不是简单的ans++，千万别想错了，网状是最复杂的！</span></span><br></pre></td></tr></table></figure>



<p>看一题：</p>
<p>[1003 Emergency (25分)](/Users/kirito/Documents/Typora–markdown笔记/笔记/复试/机试/PAT刷题/A组/1003 Emergency (25分).md)</p>
<p>再来一道</p>
<p>[1018 Public Bike Management (30分)](/Users/kirito/Documents/Typora–markdown笔记/笔记/复试/机试/PAT刷题/A组/1018 Public Bike Management (30分).md)</p>
<p>然而，我发现自己无法用单纯的Dijkstra做出第二道题，解析说Dijkstra不能做出来，要用Dijkstra+DFS来做，我简直想哭，当时想着，哪怕是多一个属性，我也可以想出来，顶多是复杂一点，背下Dijkstra出了负数环怕一点，其他都不怕，而这次不同了，这次Dijkstra无法处理。。。</p>
<p>哎，还是不要偷懒的好，下面恶补一下DFS+Dijkstra的方法：</p>
<blockquote>
<p> <img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414102153377.png" alt="image-20200414102153377"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414103009429.png" alt="image-20200414103009429"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414103213661.png" alt="image-20200414103213661"></p>
</blockquote>
<p>为此，我再默写一遍：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> G[MAXV][MAXV];</span><br><span class="line"><span class="keyword">int</span> d[MAXV];</span><br><span class="line"><span class="keyword">bool</span> vis[MAXV] = &#123;<span class="literal">false</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV];</span><br><span class="line"><span class="comment">//这样Dijkstra的作用也更加纯粹，求最短路径，并记录所有最短路径，其余的附加条件在DFS中解决</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d, d + n, INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//查找最小</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//对该节点连接结点的d进行更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span>(G[u][j] + d[u] &lt; d[j]) &#123;</span><br><span class="line">                    pre[j].<span class="built_in">clear</span>();<span class="comment">//更优则清</span></span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                    d[j] = G[u][j] + d[u];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(G[u][j] + d[u] == d[j]) &#123;</span><br><span class="line">                    pre[j].push_back(u); <span class="comment">//同优添加</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414104326841.png" alt="image-20200414104326841"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200414105020615.png" alt="image-20200414105020615"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> optValue; <span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV]; <span class="comment">//最短路径集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path, temp;  <span class="comment">//一个存第二标尺最优路径，一个存当前路径</span></span><br><span class="line"><span class="keyword">int</span> st;  <span class="comment">//起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;  <span class="comment">//v为当前访问节点</span></span><br><span class="line">    <span class="keyword">if</span>(v == st) &#123;  <span class="comment">//到达起点，即叶子结点</span></span><br><span class="line">        temp.push_back(v);  <span class="comment">//入数组</span></span><br><span class="line">        <span class="keyword">int</span> value;  <span class="comment">//存放当前路径第二标尺的值</span></span><br><span class="line">        计算temp路径上第二标尺value的值;</span><br><span class="line">        <span class="keyword">if</span>(value优于optValue) &#123;</span><br><span class="line">			optValue = value;</span><br><span class="line">            path = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        temp.pop_back();  <span class="comment">//将刚刚加入的结点删除，相当于撤销操作</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp.push_back(v); <span class="comment">//将当前访问的结点加入临时路径temp最后面</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123; <span class="comment">//可以进行的选择</span></span><br><span class="line">        DFS(pre[v][i]);  </span><br><span class="line">    &#125;</span><br><span class="line">    temp.pop_back(); <span class="comment">//遍历完所有前驱结点，删除当前节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说实话，这个temp搞得算法好难理解，我可以用加大空间复杂度，来换取脑力复杂度降低</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> optValue; <span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre[MAXV]; <span class="comment">//最短路径集</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;  <span class="comment">//存第二标尺最优路径</span></span><br><span class="line"><span class="keyword">int</span> st;  <span class="comment">//起点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span> </span>&#123;  <span class="comment">//v为当前访问节点</span></span><br><span class="line">	<span class="comment">//相当于先序遍历，但是由于存储的方式是用栈，所以每条路径都是自底向上</span></span><br><span class="line">    temp.push_back(v);<span class="comment">//根</span></span><br><span class="line">    <span class="keyword">if</span>(v == st) &#123;  <span class="comment">//到达起点，即叶子结点</span></span><br><span class="line">        <span class="keyword">int</span> value;  <span class="comment">//存放当前路径第二标尺的值</span></span><br><span class="line">        计算temp路径上第二标尺value的值;</span><br><span class="line">        <span class="keyword">if</span>(value优于optValue) &#123;</span><br><span class="line">			optValue = value;</span><br><span class="line">            path = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//孩子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123; <span class="comment">//可以进行的选择        </span></span><br><span class="line">        DFS(pre[v][i], temp);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>之后我又默写了一遍</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须稳固一下一些代码的记忆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Dijkstra + DFS</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">G</span><span class="params">(MAXV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(MAXV, INF))</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(MAXV, <span class="literal">false</span>)</span></span>;  <span class="comment">//记录结点是否访问过,访问过的结点就是已经确定了最短距离</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pre</span><span class="params">(MAXV)</span></span>;  </span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(MAXV)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;  <span class="comment">//结点数</span></span><br><span class="line"><span class="keyword">int</span> optValue;  <span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//第二标尺的最优路径</span></span><br><span class="line"><span class="keyword">int</span> s; <span class="comment">//起点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra, s为源点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="comment">//先找d中最小</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        vis[u] == <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//对u所有邻近结点更新d数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123;</span><br><span class="line">                <span class="keyword">if</span>(G[u][j] + d[u] &lt; d[j]) &#123;</span><br><span class="line">                    d[j] = G[u][j] + d[u];</span><br><span class="line">                    pre[j].<span class="built_in">clear</span>();</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(G[u][j] + d[u] == d[j]) &#123;</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS---个人写法,更加容易理解</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> v, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;  <span class="comment">//第一次输入的v是目标结点, 在递归中的含义是当前访问节点,temp是当前路径</span></span><br><span class="line">    <span class="comment">//先序遍历,放入</span></span><br><span class="line">    temp.push_back(v);</span><br><span class="line">    <span class="comment">//判断是否到达叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(v == s) &#123;</span><br><span class="line">        <span class="keyword">int</span> value; <span class="comment">//存放当前路径第二标尺的值</span></span><br><span class="line">        <span class="comment">//todo </span></span><br><span class="line">        计算value;</span><br><span class="line">        <span class="keyword">if</span>(value 优于 optValue) &#123;</span><br><span class="line">            optValue = value;</span><br><span class="line">            path = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        DFS(pre[v][i], temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有默写了一遍！！！！ DFS做出了优化！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 首先要明白Dijkstra是用来解决什么问题的:</span></span><br><span class="line"><span class="comment"> * Dijkstra用于解决单源最短路径问题, 就是一点出发,到其他各点的最短路径</span></span><br><span class="line"><span class="comment"> * 所以Dijkstra函数的输入一定是出发节点</span></span><br><span class="line"><span class="comment"> * 而DFS作为由回溯路径的函数,传入的是终点</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra+DFS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据的定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>; <span class="comment">//设为距离最大值即不可达</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>; <span class="comment">//结点最大值,用于初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">G</span><span class="params">(MAXV, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(MAXV, INF))</span></span>; <span class="comment">//邻接矩阵,存距离</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">vis</span><span class="params">(MAXV, <span class="literal">false</span>)</span></span>; <span class="comment">//记录节点是否被访问过,凡是被访问过即确定了最终距离</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(MAXV)</span></span>; <span class="comment">//距离数据,存储s到达每个结点的最短距离</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">pre</span><span class="params">(MAXV)</span></span>; <span class="comment">//用于记录路径,pre[i]代表了最短路径中,结点i的前一个结点的集合</span></span><br><span class="line"><span class="keyword">int</span> n; <span class="comment">//结点数</span></span><br><span class="line"><span class="keyword">int</span> optValue; <span class="comment">//第二标尺最优值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//第二标尺最优路径</span></span><br><span class="line"><span class="keyword">int</span> s; <span class="comment">//起点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Dijkstra</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">(<span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">fill</span>(d.<span class="built_in">begin</span>(), d.<span class="built_in">end</span>(), INF);</span><br><span class="line">    d[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">//外层循环,每一次确定一个结点的最短距离</span></span><br><span class="line">        <span class="comment">//寻找最短距离</span></span><br><span class="line">        <span class="keyword">int</span> MIN = INF, u = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; d[j] &lt; MIN) &#123;</span><br><span class="line">                u = j;</span><br><span class="line">                MIN = d[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(u == <span class="number">-1</span>) <span class="keyword">return</span>; <span class="comment">//如果都访问过了,则跳出</span></span><br><span class="line">        vis[u] = <span class="literal">true</span>; <span class="comment">//设置该结点访问,即该节点的最短距离已经算出</span></span><br><span class="line">        <span class="comment">//然后以该节点进行更新附近结点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(vis[j] == <span class="literal">false</span> &amp;&amp; G[u][j] != INF) &#123; <span class="comment">//未访问,且相连</span></span><br><span class="line">                <span class="keyword">if</span>(d[u] + G[u][j] &lt; d[j]) &#123; <span class="comment">//更新</span></span><br><span class="line">                    d[j] = d[u] + G[u][j];</span><br><span class="line">                    pre[j].<span class="built_in">clear</span>();</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span>(d[u] + G[u][j] == d[j]) &#123;</span><br><span class="line">                    pre[j].push_back(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//DFS,优化版本!</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp)</span></span>&#123;  <span class="comment">//第一次使用时要在temp中放目的结点</span></span><br><span class="line">    <span class="keyword">int</span> v = temp.front();</span><br><span class="line">    <span class="comment">//先序遍历,直接访问,放入   </span></span><br><span class="line">    <span class="keyword">if</span>(v == s) &#123; <span class="comment">//如果到达了终点</span></span><br><span class="line">        <span class="keyword">int</span> value;<span class="comment">//value记录第二标尺值</span></span><br><span class="line">        <span class="comment">//todo</span></span><br><span class="line">        计算value值;</span><br><span class="line">        <span class="keyword">if</span>(value 优于 optValue) &#123;</span><br><span class="line">            optValue = value;</span><br><span class="line">            path = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//进行选择</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pre[v].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        temp.push_back(pre[v][i]); <span class="comment">// 选择</span></span><br><span class="line">        DFS(temp);</span><br><span class="line">        temp.pop_back();  <span class="comment">//撤销</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="拓扑排序–判环"><a href="#拓扑排序–判环" class="headerlink" title="拓扑排序–判环"></a>拓扑排序–判环</h2><h3 id="1-有向无环图"><a href="#1-有向无环图" class="headerlink" title="1.有向无环图"></a>1.有向无环图</h3><blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406210445011.png" alt="image-20200406210445011"></p>
</blockquote>
<h3 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2.拓扑排序"></a>2.拓扑排序</h3><blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406211123526.png" alt="image-20200406211123526"></p>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406211138761.png" alt="image-20200406211138761"></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; G[MAXV];  <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n, m, inDegree[MAXV];  <span class="comment">//顶点数，边数，入度数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;  <span class="comment">//记录加入拓扑排序的顶点数，最后用来验证结果</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;  <span class="comment">//队列为核心，利用队列特性解决</span></span><br><span class="line">    <span class="comment">//先把入度为0的入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) <span class="built_in">queue</span>.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心算法，不断出队，减入度（去出边），如果减了之后为0就入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); <span class="comment">//得队首</span></span><br><span class="line">        <span class="comment">//此时可以输出队首元素：printf("%d\n", u);</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="comment">//减u对应结点所连接结点的入度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];<span class="comment">//所连接的结点号，后面重复用到，所以记录一下</span></span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>(); <span class="comment">//除去u所有出边</span></span><br><span class="line">        num++;  <span class="comment">//每出一个记录一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == n) <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">//拓扑排序成功，无环</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">//拓扑排序成功，有环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><img src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/image20200406214036081.png" alt="image-20200406214036081"></p>
</blockquote>
<blockquote>
<p>拓扑排序的本质实现应该是贪心算法，当然，如果判断有无环，用DFS和BFS也可以做到</p>
</blockquote>
<p>默写了一遍：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须稳固一下一些代码的记忆</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">G</span><span class="params">(MAXV)</span></span>; <span class="comment">//邻接表</span></span><br><span class="line"><span class="keyword">int</span> n, inDegree[MAXV]; <span class="comment">//顶点数, 边数, 入度数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span></span>&#123;  <span class="comment">//return的结果是是否为有向无环图</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;  <span class="comment">//记录入队数,用于验证结果</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//先把入度为0的点入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心算法, 不断出队, 对其邻接结点的入度--,然后去出边, 如果减了之后入度为0便入队</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); <span class="comment">// 得队首</span></span><br><span class="line">        <span class="comment">//这里可以print(), 用于得到排序顺序 </span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123;  <span class="comment">//遍历所有邻接点,入队减1</span></span><br><span class="line">            <span class="keyword">int</span> v = G[u][i];</span><br><span class="line">            inDegree[v]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[v] == <span class="number">0</span>) q.push(v);</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>();  <span class="comment">//除去u的出边</span></span><br><span class="line">        num++; <span class="comment">//每一个记录一下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>又双默写了一遍：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拓扑排序的核心思想是用队列存入度为0的结点,每次都将这个结点从整个图中去掉,然后更新结点入度,同时将更新后入度为0的结点入队,最后结束</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">1000000000</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">1000</span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">G</span><span class="params">(MAXV)</span></span>; <span class="comment">// 邻接表</span></span><br><span class="line"><span class="keyword">int</span> n, inDegree[MAXV]; <span class="comment">// 顶点数, 边数, 入度数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//拓扑排序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">topologicalSort</span><span class="params">()</span> </span>&#123; <span class="comment">//return结果用于判断是否为有向无环图</span></span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录出队数,用于验证结果</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="comment">//入度为0入队</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心算法</span></span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(); <span class="comment">//取首</span></span><br><span class="line">        <span class="comment">//to do sth. 这里可以打印队首,用以显示拓扑排序的结果</span></span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; G[u].<span class="built_in">size</span>(); i++) &#123; <span class="comment">//将u以出度连接的结点的入度都减一</span></span><br><span class="line">            inDegree[G[u][i]]--;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[G[u][i]] == <span class="number">0</span>) q.push(G[u][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        G[u].<span class="built_in">clear</span>(); <span class="comment">//去出边</span></span><br><span class="line">        num++; <span class="comment">//每出队一个,记录一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num == n) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
















    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" rel="tag"># 最短路径&拓扑排序</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/22/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/LeetCode/%E4%B8%A4%E5%9C%B0%E8%B0%83%E5%BA%A6/" rel="prev" title="两地调度">
      <i class="fa fa-chevron-left"></i> 两地调度
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/27/%E5%AD%A6%E4%B9%A0/%E7%BC%96%E7%A8%8B%E9%A2%98/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/3-2-DP-%E9%A2%98%E9%9B%862/" rel="next" title="DP-题集2">
      DP-题集2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#最短路径和拓扑排序"><span class="nav-text">最短路径和拓扑排序</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#最短路径"><span class="nav-text">最短路径</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra算法"><span class="nav-text">Dijkstra算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拓扑排序–判环"><span class="nav-text">拓扑排序–判环</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-有向无环图"><span class="nav-text">1.有向无环图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-拓扑排序"><span class="nav-text">2.拓扑排序</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="KiritoH"
      src="https://demo-1258985652.cos.ap-guangzhou.myqcloud.com/2020/06/09/01.jpg">
  <p class="site-author-name" itemprop="name">KiritoH</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">56</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">KiritoH</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>


    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
